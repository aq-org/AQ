class BytecodeGenerator {
 public:
  BytecodeGenerator();
  ~BytecodeGenerator() = default;

  void GenerateBytecode(CompoundNode* stmt);

 private:
  class Memory {
   public:
    Memory() { IsBigEndian(); }
    ~Memory() = default;

    std::size_t Add(uint8_t type, std::size_t size) {
      std::cout << "Add1" << std::endl;
      std::size_t index = memory_.size() + 1;
      type_.push_back(type);
      memory_.resize(all_size_ + size);
      all_size_ += size;

      if (type > 0x0F) return index;

      for (std::size_t i = 0; i < size; i++) {
        if (memory_.size() % 2 != 0) {
          memory_.push_back(0);
          all_size_++;
          type_[type_.size()] = (type_[type_.size()] << 4) | type;
        } else {
          memory_.push_back(0);
          all_size_ += 2;
          type_.push_back(type);
        }
      }

      return index;
    }

    std::size_t Add(uint8_t type, std::size_t size, const void* data) {
      std::cout << "Add2" << std::endl;
      std::size_t index = memory_.size() + 1;
      type_.push_back(type);
      memory_.resize(all_size_ + size);
      all_size_ += size;

      if (type > 0x0F) return index;

      void* memory_data = malloc(size);

      std::size_t read_index = 0;
      while (read_index < size) {
        switch (type) {
          case 0x01:
            *(int8_t*)memory_data = *(int8_t*)data;
            data = (void*)((uintptr_t)data + 1);
            read_index += 1;
            memory_data = (void*)((uintptr_t)memory_data + 1);
            break;
          case 0x02:
            *(int*)(memory_data) =
                is_big_endian ? *(int*)data : SwapInt(*(int*)data);
            data = (void*)((uintptr_t)data + 4);
            read_index += 4;
            memory_data = (void*)((uintptr_t)memory_data + 4);
            break;
          case 0x03:
            *(long*)(memory_data) =
                is_big_endian ? *(long*)data : SwapLong(*(long*)data);
            data = (void*)((uintptr_t)data + 8);
            read_index += 8;
            memory_data = (void*)((uintptr_t)memory_data + 8);
            break;
          case 0x04:
            *(float*)(memory_data) =
                is_big_endian ? *(float*)data : SwapFloat(*(float*)data);
            data = (void*)((uintptr_t)data + 4);
            read_index += 4;
            memory_data = (void*)((uintptr_t)memory_data + 4);
            break;
          case 0x05:
            *(double*)(memory_data) =
                is_big_endian ? *(double*)data : SwapDouble(*(double*)data);
            data = (void*)((uintptr_t)data + 8);
            read_index += 8;
            memory_data = (void*)((uintptr_t)memory_data + 8);
            break;
          case 0x06:
            *(uint64_t*)(memory_data) = is_big_endian
                                            ? *(uint64_t*)data
                                            : SwapUint64t(*(uint64_t*)data);
            data = (void*)((uintptr_t)data + 8);
            read_index += 8;
            memory_data = (void*)((uintptr_t)memory_data + 8);
          default:
            return index;
        }
      }

      for (std::size_t i = 0; i < size; i++) {
        if (memory_.size() % 2 != 0) {
          memory_.push_back(*(uint64_t*)memory_data);
          memory_data = (void*)((uintptr_t)memory_data + 1);
          all_size_++;
          type_[type_.size()] = (type_[type_.size()] << 4) | type;
        } else {
          memory_.push_back(*(uint64_t*)memory_data);
          memory_data = (void*)((uintptr_t)memory_data + 1);
          all_size_ += 2;
          type_.push_back(type);
        }
      }
      return index;
    }

    size_t GetSize() { return memory_.size() + type_.size(); }
    std::vector<uint8_t> GetMemory() { return memory_; }
    std::vector<uint8_t> GetType() { return type_; }

   private:
    std::size_t all_size_ = 0;
    std::vector<uint8_t> memory_;
    std::vector<uint8_t> type_;
    bool is_big_endian = false;

    void IsBigEndian() {
      uint16_t test_data = 0x0011;
      is_big_endian = *(uint8_t*)&test_data == 0x00;
    }

    int SwapInt(int x) {
      uint32_t ux = (uint32_t)x;
      ux = ((ux << 24) & 0xFF000000) | ((ux << 8) & 0x00FF0000) |
           ((ux >> 8) & 0x0000FF00) | ((ux >> 24) & 0x000000FF);
      return (int)ux;
    }

    long SwapLong(long x) {
      uint64_t ux = (uint64_t)x;
      ux = ((ux << 56) & 0xFF00000000000000ULL) |
           ((ux << 40) & 0x00FF000000000000ULL) |
           ((ux << 24) & 0x0000FF0000000000ULL) |
           ((ux << 8) & 0x000000FF00000000ULL) |
           ((ux >> 8) & 0x00000000FF000000ULL) |
           ((ux >> 24) & 0x0000000000FF0000ULL) |
           ((ux >> 40) & 0x000000000000FF00ULL) |
           ((ux >> 56) & 0x00000000000000FFULL);
      return (long)ux;
    }

    float SwapFloat(float x) {
      uint32_t ux;
      memcpy(&ux, &x, sizeof(uint32_t));
      ux = ((ux << 24) & 0xFF000000) | ((ux << 8) & 0x00FF0000) |
           ((ux >> 8) & 0x0000FF00) | ((ux >> 24) & 0x000000FF);
      float result;
      memcpy(&result, &ux, sizeof(float));
      return result;
    }

    double SwapDouble(double x) {
      uint64_t ux;
      memcpy(&ux, &x, sizeof(uint64_t));
      ux = ((ux << 56) & 0xFF00000000000000ULL) |
           ((ux << 40) & 0x00FF000000000000ULL) |
           ((ux << 24) & 0x0000FF0000000000ULL) |
           ((ux << 8) & 0x000000FF00000000ULL) |
           ((ux >> 8) & 0x00000000FF000000ULL) |
           ((ux >> 24) & 0x0000000000FF0000ULL) |
           ((ux >> 40) & 0x000000000000FF00ULL) |
           ((ux >> 56) & 0x00000000000000FFULL);
      double result;
      memcpy(&result, &ux, sizeof(double));
      return result;
    }

    uint64_t SwapUint64t(uint64_t x) {
      x = ((x << 56) & 0xFF00000000000000ULL) |
          ((x << 40) & 0x00FF000000000000ULL) |
          ((x << 24) & 0x0000FF0000000000ULL) |
          ((x << 8) & 0x000000FF00000000ULL) |
          ((x >> 8) & 0x00000000FF000000ULL) |
          ((x >> 24) & 0x0000000000FF0000ULL) |
          ((x >> 40) & 0x000000000000FF00ULL) |
          ((x >> 56) & 0x00000000000000FFULL);
      return x;
    }
  };

  class Bytecode {
   public:
    // Bytecode(std::size_t oper) { oper_ = oper; }
    Bytecode(std::size_t oper, ...) {
      oper_ = oper;
      va_list args;
      va_start(args, oper);
      for (std::size_t i = 0; i < oper; i++) {
        arg_.push_back(va_arg(args, std::size_t));
      }
      va_end(args);
    }
    Bytecode(std::size_t oper, std::vector<std::size_t> args) {
      oper_ = oper;
      arg_ = args;
    }
    ~Bytecode() = default;

    uint8_t GetOper() { return oper_; }
    std::vector<std::size_t> GetArgs() { return arg_; }

   private:
    uint8_t oper_;
    std::vector<std::size_t> arg_;
  };

  void HandleFuncDecl(FuncDeclNode* func_decl);
  void HandleVarDecl(VarDeclNode* var_decl, std::vector<Bytecode>& code);
  void HandleArrayDecl(ArrayDeclNode* array_decl, std::vector<Bytecode>& code);
  void HandleStmt(StmtNode* stmt, std::vector<Bytecode>& code);
  std::size_t HandleExpr(ExprNode* expr, std::vector<Bytecode>& code);
  std::size_t HandleUnaryExpr(UnaryNode* expr, std::vector<Bytecode>& code);
  std::size_t HandleBinaryExpr(BinaryNode* expr, std::vector<Bytecode>& code);
  std::size_t HandleFuncInvoke(FuncNode* func, std::vector<Bytecode>& code);
  std::size_t GetIndex(ExprNode* expr, std::vector<Bytecode>& code);
  std::size_t AddConstInt8t(int8_t value);
  uint8_t GetExprVmType(ExprNode* expr);
  uint8_t GetExprPtrValueVmType(ExprNode* expr);
  std::size_t GetExprVmSize(uint8_t type);
  uint64_t SwapUint64t(uint64_t x);
  void InsertUint64ToCode(uint64_t value);
  size_t EncodeUleb128(size_t value, std::vector<uint8_t>& output);

  // enum class BytecodeType { kGlobal, KFunc, kCompound, kIf, kWhile, kFor };
  LexMap<FuncDeclNode> func_table_;
  LexMap<std::pair<VarDeclNode*, std::size_t>> var_table_;
  // LexMap<ArrayDeclNode*> array_table_;
  std::vector<std::pair<std::string, std::vector<Bytecode>>> func_list_;
  Memory global_memory_;
  std::vector<Bytecode> global_code_;
  std::vector<uint8_t> code_;
  std::size_t undefined_name_count_ = 0;
};

BytecodeGenerator::BytecodeGenerator() {
  std::vector<Bytecode> code;
  code.push_back(Bytecode(_AQVM_OPERATOR_NOP));
  func_list_.push_back(
      std::pair<std::string, std::vector<Bytecode>>("$0", code));

  FuncNode* func = new FuncNode();
  Token token;
  std::string* name_ptr = new std::string("print");
  token.type = Token::Type::IDENTIFIER;
  token.value.string = name_ptr;
  IdentifierNode* name = new IdentifierNode();
  name->SetIdentifierNode(token);
  Type* arg_base_type = new Type();
  arg_base_type->SetType(Type::BaseType::kChar);
  PointerType* arg_type = new PointerType();
  arg_type->SetSubType(arg_base_type);
  std::vector<ExprNode*> args;
  VarDeclNode* var_decl = new VarDeclNode();
  var_decl->SetVarDeclNode(arg_type, name);
  func->SetFuncNode(name, args);
  FuncDeclNode* func_decl = new FuncDeclNode();
  Type* type = new Type();
  type->SetType(Type::BaseType::kInt);
  func_decl->SetFuncDeclNode(type, func, nullptr);
}

void BytecodeGenerator::GenerateBytecode(CompoundNode* stmt) {
  if (stmt == nullptr) return;
  std::cout << "BytecodeGenerator::GenerateBytecode OK" << std::endl;
  for (std::size_t i = 0; i < stmt->GetStmts().size(); i++) {
    switch (stmt->GetStmts()[i]->GetType()) {
      case StmtNode::StmtType::kFuncDecl:
        HandleFuncDecl(dynamic_cast<FuncDeclNode*>(stmt->GetStmts()[i]));
        break;

      case StmtNode::StmtType::kVarDecl:
        HandleVarDecl(dynamic_cast<VarDeclNode*>(stmt->GetStmts()[i]),
                      global_code_);
        break;

      case StmtNode::StmtType::kArrayDecl:
        HandleArrayDecl(dynamic_cast<ArrayDeclNode*>(stmt->GetStmts()[i]),
                        global_code_);
        break;

      default:
        break;
    }
  }

  code_.push_back(0x41);
  code_.push_back(0x51);
  code_.push_back(0x42);
  code_.push_back(0x43);

  size_t memory_size = global_memory_.GetSize();
  std::cout << "Memory Size: " << memory_size << std::endl;
  // if (global_memory_.GetSize() % 2 != 0) memory_size++;
  uint16_t test_data = 0x0011;
  bool is_big_endian = *(uint8_t*)&test_data == 0x00;
  InsertUint64ToCode(is_big_endian ? memory_size : SwapUint64t(memory_size));
  code_.insert(code_.end(), global_memory_.GetMemory().begin(),
               global_memory_.GetMemory().end());
  code_.insert(code_.end(), global_memory_.GetType().begin(),
               global_memory_.GetType().end());

  for (size_t i = 0; i < func_list_.size(); i++) {
    size_t func_size = 0;
    size_t func_size_index = code_.size();
    code_.insert(code_.end(), 8, 0);
    code_.insert(code_.end(), func_list_[i].first.c_str(),
                 func_list_[i].first.c_str() + func_list_[i].first.size() + 1);
    func_size += func_list_[i].first.size() + 1;

    for (size_t j = 0; j < func_list_[i].second.size(); j++) {
      std::vector<uint8_t> buffer;
      switch (func_list_[i].second[j].GetOper()) {
        case _AQVM_OPERATOR_NOP:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_NOP);
          break;

        case _AQVM_OPERATOR_LOAD:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_LOAD);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_STORE:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_STORE);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_NEW:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_NEW);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_FREE:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_FREE);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_PTR:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_PTR);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_ADD:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_ADD);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[2], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_SUB:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_SUB);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[2], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_MUL:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_MUL);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[2], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_DIV:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_DIV);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[2], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_REM:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_REM);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[2], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_NEG:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_NEG);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_SHL:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_SHL);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[2], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_SHR:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_SHR);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[2], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_SAR:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_SAR);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[2], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_IF:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_IF);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[2], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_AND:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_AND);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[2], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_OR:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_OR);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[2], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_XOR:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_XOR);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[2], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_CMP:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_CMP);
          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[1], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[2], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[3], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_INVOKE:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_INVOKE);

          for (size_t i = 0; i < func_list_[i].second[j].GetArgs().size();
               i++) {
            func_size +=
                EncodeUleb128(func_list_[i].second[j].GetArgs()[i], buffer);
            code_.insert(code_.end(), buffer.begin(), buffer.end());
            buffer.clear();
          }
          break;

        case _AQVM_OPERATOR_RETURN:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_RETURN);
          break;

        case _AQVM_OPERATOR_GOTO:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_GOTO);

          func_size +=
              EncodeUleb128(func_list_[i].second[j].GetArgs()[0], buffer);
          code_.insert(code_.end(), buffer.begin(), buffer.end());
          buffer.clear();
          break;

        case _AQVM_OPERATOR_THROW:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_THROW);
          break;

        case _AQVM_OPERATOR_WIDE:
          func_size++;
          code_.push_back(_AQVM_OPERATOR_WIDE);
          break;

        default:
          break;
      }
    }
    func_size = is_big_endian ? func_size : SwapUint64t(func_size);
    for (int i = 0; i < 8; i++) {
      code_.insert(code_.begin() + func_size_index + i,
                   static_cast<uint8_t>((func_size >> (i * 8)) & 0xFF));
    }
  }

  std::string filename = "a.out";
  std::ofstream outFile(filename, std::ios::binary);
  if (!outFile) {
    std::cerr << "Can't open file: " << filename << std::endl;
    return;
  }

  outFile.write(reinterpret_cast<const char*>(code_.data()), code_.size());
  outFile.close();

  if (!outFile) {
    std::cerr << "Failed to write file: " << filename << std::endl;
  } else {
    std::cout << "Write file success: " << filename << std::endl;
  }
}

void BytecodeGenerator::HandleFuncDecl(FuncDeclNode* func_decl) {
  std::vector<Bytecode> code;
  std::cout << "BytecodeGenerator::HandleFuncDecl OK" << std::endl;
  func_table_.Insert(*func_decl->GetStat()->GetName(), *func_decl);
  HandleStmt(func_decl->GetStmts(), code);
  func_list_.push_back(std::pair<std::string, std::vector<Bytecode>>(
      *func_decl->GetStat()->GetName(), code));
}

void BytecodeGenerator::HandleVarDecl(VarDeclNode* var_decl,
                                      std::vector<Bytecode>& code) {
  std::cout << "BytecodeGenerator::HandleVarDecl OK" << std::endl;
  Type* var_type = var_decl->GetVarType();
  while (var_type->GetType() != Type::TypeType::kBase ||
         var_type->GetType() != Type::TypeType::kPointer ||
         var_type->GetType() != Type::TypeType::kArray ||
         var_type->GetType() != Type::TypeType::kReference) {
    switch (var_type->GetType()) {
      case Type::TypeType::kConst:
        var_type = dynamic_cast<ConstType*>(var_type)->GetSubType();
        break;
      default:
        return;
    }
  }
  uint8_t vm_type = 0x00;
  if (var_type->GetType() == Type::TypeType::kBase) {
    switch (var_type->GetBaseType()) {
      case Type::BaseType::kVoid:
        vm_type = 0x00;
        break;
      case Type::BaseType::kBool:
      case Type::BaseType::kChar:
        vm_type = 0x01;
        break;
      case Type::BaseType::kShort:
      case Type::BaseType::kInt:
        vm_type = 0x02;
        break;
      case Type::BaseType::kLong:
        vm_type = 0x03;
        break;
      case Type::BaseType::kFloat:
        vm_type = 0x04;
        break;
      case Type::BaseType::kDouble:
        vm_type = 0x05;
        break;
      case Type::BaseType::kStruct:
      case Type::BaseType::kUnion:
      case Type::BaseType::kEnum:
      case Type::BaseType::kPointer:
      case Type::BaseType::kArray:
      case Type::BaseType::kFunction:
      case Type::BaseType::kTypedef:
      case Type::BaseType::kAuto:
        vm_type = 0x06;
        break;
      default:
        vm_type = 0x00;
        break;
    }
  } else if (var_type->GetType() == Type::TypeType::kPointer ||
             var_type->GetType() == Type::TypeType::kReference) {
    vm_type = 0x06;
  }
  if (var_decl->GetValue().empty()) {
    var_table_.Insert(
        *var_decl->GetName(),
        std::pair<VarDeclNode*, std::size_t>(
            var_decl, global_memory_.Add(vm_type, var_type->GetSize())));
  } else {
    size_t var_index = global_memory_.Add(vm_type, var_type->GetSize());
    size_t value_index = HandleExpr(var_decl->GetValue()[0], code);
    code.push_back(
        Bytecode(_AQVM_OPERATOR_ADD, var_index, value_index, AddConstInt8t(0)));
  }
}

void BytecodeGenerator::HandleArrayDecl(ArrayDeclNode* array_decl,
                                        std::vector<Bytecode>& code) {
  Type* array_type = array_decl->GetVarType();
  if (array_type->GetType() == Type::TypeType::kConst)
    array_type = dynamic_cast<ConstType*>(array_type)->GetSubType();
  uint8_t vm_type = 0x00;
  if (array_type->GetType() == Type::TypeType::kBase) {
    switch (array_type->GetBaseType()) {
      case Type::BaseType::kVoid:
        vm_type = 0x00;
        break;
      case Type::BaseType::kBool:
      case Type::BaseType::kChar:
        vm_type = 0x01;
        break;
      case Type::BaseType::kShort:
      case Type::BaseType::kInt:
        vm_type = 0x02;
        break;
      case Type::BaseType::kLong:
        vm_type = 0x03;
        break;
      case Type::BaseType::kFloat:
        vm_type = 0x04;
        break;
      case Type::BaseType::kDouble:
        vm_type = 0x05;
        break;
      case Type::BaseType::kStruct:
      case Type::BaseType::kUnion:
      case Type::BaseType::kEnum:
      case Type::BaseType::kPointer:
      case Type::BaseType::kArray:
      case Type::BaseType::kFunction:
      case Type::BaseType::kTypedef:
      case Type::BaseType::kAuto:
        vm_type = 0x06;
        break;
      default:
        vm_type = 0x00;
        break;
    }
  } else if (array_type->GetType() == Type::TypeType::kPointer ||
             array_type->GetType() == Type::TypeType::kArray ||
             array_type->GetType() == Type::TypeType::kReference) {
    vm_type = 0x06;
  }
  if (array_decl->GetValue().empty()) {
    size_t array_index = global_memory_.Add(vm_type, array_type->GetSize());
    size_t array_ptr_index = global_memory_.Add(0x06, 8);
    code.push_back(Bytecode(_AQVM_OPERATOR_PTR, array_index, array_ptr_index));
    var_table_.Insert(
        *array_decl->GetName(),
        std::pair<VarDeclNode*, std::size_t>(
            dynamic_cast<VarDeclNode*>(array_decl), array_ptr_index));
  } else {
    size_t array_index = global_memory_.Add(vm_type, array_type->GetSize());
    size_t array_ptr_index = global_memory_.Add(0x06, 8);
    code.push_back(Bytecode(_AQVM_OPERATOR_PTR, array_index, array_ptr_index));
    for (size_t i = 0; i < array_decl->GetValue().size(); i++) {
      size_t value_index = HandleExpr(array_decl->GetValue()[i], code);
      code.push_back(Bytecode(_AQVM_OPERATOR_ADD, array_index, value_index,
                              AddConstInt8t(0)));
    }
    var_table_.Insert(
        *array_decl->GetName(),
        std::pair<VarDeclNode*, std::size_t>(
            dynamic_cast<VarDeclNode*>(array_decl), array_ptr_index));
  }
}

std::size_t BytecodeGenerator::HandleExpr(ExprNode* expr,
                                          std::vector<Bytecode>& code) {
  if (expr->GetType() == StmtNode::StmtType::kUnary) {
    return HandleUnaryExpr(dynamic_cast<UnaryNode*>(expr), code);
  } else if (expr->GetType() == StmtNode::StmtType::kBinary) {
    return HandleBinaryExpr(dynamic_cast<BinaryNode*>(expr), code);
  }

  return GetIndex(expr, code);
}
std::size_t BytecodeGenerator::HandleUnaryExpr(UnaryNode* expr,
                                               std::vector<Bytecode>& code) {
  std::size_t sub_expr = HandleExpr(expr->GetExpr(), code);
  switch (expr->GetOperator()) {
    case UnaryNode::Operator::kPostInc: {  // ++ (postfix)
      uint8_t vm_type = GetExprVmType(expr->GetExpr());
      std::size_t new_index =
          global_memory_.Add(vm_type, GetExprVmSize(vm_type));
      code.push_back(
          Bytecode(_AQVM_OPERATOR_ADD, new_index, sub_expr, AddConstInt8t(0)));
      code.push_back(
          Bytecode(_AQVM_OPERATOR_ADD, sub_expr, sub_expr, AddConstInt8t(1)));
      return new_index;
    }
    case UnaryNode::Operator::kPostDec: {  // -- (postfix)
      uint8_t vm_type = GetExprVmType(expr->GetExpr());
      std::size_t new_index =
          global_memory_.Add(vm_type, GetExprVmSize(vm_type));
      code.push_back(
          Bytecode(_AQVM_OPERATOR_ADD, new_index, sub_expr, AddConstInt8t(0)));
      code.push_back(
          Bytecode(_AQVM_OPERATOR_SUB, sub_expr, sub_expr, AddConstInt8t(1)));
      return new_index;
    }
    case UnaryNode::Operator::kPreInc:  // ++ (prefix)
      code.push_back(
          Bytecode(_AQVM_OPERATOR_ADD, sub_expr, sub_expr, AddConstInt8t(1)));
      return sub_expr;
    case UnaryNode::Operator::kPreDec:  // -- (prefix)
      code.push_back(
          Bytecode(_AQVM_OPERATOR_SUB, sub_expr, sub_expr, AddConstInt8t(1)));
      return sub_expr;
    case UnaryNode::Operator::kAddrOf: {  // & (address of)
      std::size_t ptr_index = global_memory_.Add(0x06, 8);
      code.push_back(Bytecode(_AQVM_OPERATOR_PTR, sub_expr, ptr_index));
      return ptr_index;
    }
    case UnaryNode::Operator::kDeref: {  // * (dereference)
      uint8_t vm_type = GetExprVmType(expr->GetExpr());
      std::size_t new_index =
          global_memory_.Add(vm_type, GetExprVmSize(vm_type));
      code.push_back(Bytecode(_AQVM_OPERATOR_LOAD, sub_expr, new_index));
      return new_index;
    }
    case UnaryNode::Operator::kPlus:  // + (unary plus)
      return sub_expr;
    case UnaryNode::Operator::kMinus: {  // - (unary minus)
      uint8_t vm_type = GetExprVmType(expr->GetExpr());
      std::size_t new_index =
          global_memory_.Add(vm_type, GetExprVmSize(vm_type));
      code.push_back(Bytecode(_AQVM_OPERATOR_NEG, new_index, sub_expr));
      return new_index;
    }
    case UnaryNode::Operator::kNot: {  // ! (logical NOT)
      uint8_t vm_type = GetExprVmType(expr->GetExpr());
      std::size_t new_index =
          global_memory_.Add(vm_type, GetExprVmSize(vm_type));
      code.push_back(Bytecode(_AQVM_OPERATOR_NEG, new_index, sub_expr));
      return new_index;
    }
    case UnaryNode::Operator::kBitwiseNot:  // ~ (bitwise NOT)
                                            // TODO
    default:
      return sub_expr;
  }
}
std::size_t BytecodeGenerator::HandleBinaryExpr(BinaryNode* expr,
                                                std::vector<Bytecode>& code) {
  std::size_t left = HandleExpr(expr->GetLeftExpr(), code);
  std::size_t right = HandleExpr(expr->GetRightExpr(), code);
  uint8_t left_type = GetExprVmType(expr->GetLeftExpr());
  uint8_t right_type = GetExprVmType(expr->GetRightExpr());
  uint8_t result_type = left_type > right_type ? left_type : right_type;

  switch (expr->GetOperator()) {
    case BinaryNode::Operator::kAdd: {  // +
      std::size_t result =
          global_memory_.Add(result_type, GetExprVmSize(result_type));
      code.push_back(Bytecode(_AQVM_OPERATOR_ADD, result, left, right));
      return result;
    }
    case BinaryNode::Operator::kSub: {  // -
      std::size_t result =
          global_memory_.Add(result_type, GetExprVmSize(result_type));
      code.push_back(Bytecode(_AQVM_OPERATOR_SUB, result, left, right));
      return result;
    }
    case BinaryNode::Operator::kMul: {  // *
      std::size_t result =
          global_memory_.Add(result_type, GetExprVmSize(result_type));
      code.push_back(Bytecode(_AQVM_OPERATOR_MUL, result, left, right));
      return result;
    }
    case BinaryNode::Operator::kDiv: {  // /
      std::size_t result =
          global_memory_.Add(result_type, GetExprVmSize(result_type));
      code.push_back(Bytecode(_AQVM_OPERATOR_DIV, result, left, right));
      return result;
    }
    case BinaryNode::Operator::kRem: {  // %
      std::size_t result =
          global_memory_.Add(result_type, GetExprVmSize(result_type));
      code.push_back(Bytecode(_AQVM_OPERATOR_REM, result, left, right));
      return result;
    }
    case BinaryNode::Operator::kAnd: {  // &
      std::size_t result =
          global_memory_.Add(result_type, GetExprVmSize(result_type));
      code.push_back(Bytecode(_AQVM_OPERATOR_AND, result, left, right));
      return result;
    }
    case BinaryNode::Operator::kOr: {  // |
      std::size_t result =
          global_memory_.Add(result_type, GetExprVmSize(result_type));
      code.push_back(Bytecode(_AQVM_OPERATOR_OR, result, left, right));
      return result;
    }
    case BinaryNode::Operator::kXor: {  // ^
      std::size_t result =
          global_memory_.Add(result_type, GetExprVmSize(result_type));
      code.push_back(Bytecode(_AQVM_OPERATOR_XOR, result, left, right));
      return result;
    }
    case BinaryNode::Operator::kShl: {  // <<
      std::size_t result =
          global_memory_.Add(result_type, GetExprVmSize(result_type));
      code.push_back(Bytecode(_AQVM_OPERATOR_SHL, result, left, right));
      return result;
    }
    case BinaryNode::Operator::kShr: {  // >>
      std::size_t result =
          global_memory_.Add(result_type, GetExprVmSize(result_type));
      code.push_back(Bytecode(_AQVM_OPERATOR_SHR, result, left, right));
      return result;
    }
    case BinaryNode::Operator::kLT: {  // <
      std::size_t result = global_memory_.Add(0x01, 1);
      code.push_back(Bytecode(_AQVM_OPERATOR_CMP, result, 0x04, left, right));
      return result;
    }
    case BinaryNode::Operator::kGT: {  // >
      std::size_t result = global_memory_.Add(0x01, 1);
      code.push_back(Bytecode(_AQVM_OPERATOR_CMP, result, 0x02, left, right));
      return result;
    }
    case BinaryNode::Operator::kLE: {  // <=
      std::size_t result = global_memory_.Add(0x01, 1);
      code.push_back(Bytecode(_AQVM_OPERATOR_CMP, result, 0x05, left, right));
      return result;
    }
    case BinaryNode::Operator::kGE: {  // >=
      std::size_t result = global_memory_.Add(0x01, 1);
      code.push_back(Bytecode(_AQVM_OPERATOR_CMP, result, 0x03, left, right));
      return result;
    }
    case BinaryNode::Operator::kEQ: {  // ==
      std::size_t result = global_memory_.Add(0x01, 1);
      code.push_back(Bytecode(_AQVM_OPERATOR_CMP, result, 0x00, left, right));
      return result;
    }
    case BinaryNode::Operator::kNE: {  // !=
      std::size_t result = global_memory_.Add(0x01, 1);
      code.push_back(Bytecode(_AQVM_OPERATOR_CMP, result, 0x01, left, right));
      return result;
    }
    case BinaryNode::Operator::kLAnd: {  // &&
      std::size_t result =
          global_memory_.Add(result_type, GetExprVmSize(result_type));
      code.push_back(Bytecode(_AQVM_OPERATOR_AND, result, left, right));
      return result;
    }
    case BinaryNode::Operator::kLOr: {  // ||
      std::size_t result =
          global_memory_.Add(result_type, GetExprVmSize(result_type));
      code.push_back(Bytecode(_AQVM_OPERATOR_OR, result, left, right));
      return result;
    }
    case BinaryNode::Operator::kAssign:  // =
      code.push_back(
          Bytecode(_AQVM_OPERATOR_ADD, left, right, AddConstInt8t(0)));
      return left;
    case BinaryNode::Operator::kAddAssign:  // +=
      code.push_back(Bytecode(_AQVM_OPERATOR_ADD, left, left, right));
      return left;
    case BinaryNode::Operator::kSubAssign:  // -=
      code.push_back(Bytecode(_AQVM_OPERATOR_SUB, left, left, right));
      return left;
    case BinaryNode::Operator::kMulAssign:  // *=
      code.push_back(Bytecode(_AQVM_OPERATOR_MUL, left, left, right));
      return left;
    case BinaryNode::Operator::kDivAssign:  // /=
      code.push_back(Bytecode(_AQVM_OPERATOR_DIV, left, left, right));
      return left;
    case BinaryNode::Operator::kRemAssign:  // %=
      code.push_back(Bytecode(_AQVM_OPERATOR_REM, left, left, right));
      return left;
    case BinaryNode::Operator::kAndAssign:  // &=
      code.push_back(Bytecode(_AQVM_OPERATOR_AND, left, left, right));
      return left;
    case BinaryNode::Operator::kOrAssign:  // |=
      code.push_back(Bytecode(_AQVM_OPERATOR_OR, left, left, right));
      return left;
    case BinaryNode::Operator::kXorAssign:  // ^=
      code.push_back(Bytecode(_AQVM_OPERATOR_XOR, left, left, right));
      return left;
    case BinaryNode::Operator::kShlAssign:  // <<=
      code.push_back(Bytecode(_AQVM_OPERATOR_SHL, left, left, right));
      return left;
    case BinaryNode::Operator::kShrAssign:  // >>=
      code.push_back(Bytecode(_AQVM_OPERATOR_SHR, left, left, right));
      return left;
    case BinaryNode::Operator::kComma:    // :
    case BinaryNode::Operator::kPtrMemD:  // .*
    case BinaryNode::Operator::kPtrMemI:  // ->*
    default:
      // TODO
      return left;
  }
}

void BytecodeGenerator::HandleStmt(StmtNode* stmt,
                                   std::vector<Bytecode>& code) {
  if (stmt == nullptr) return;
  switch (stmt->GetType()) {
    case StmtNode::StmtType::kCompound:
      std::cout << "kCompound" << std::endl;
      for (std::size_t i = 0;
           i < dynamic_cast<CompoundNode*>(stmt)->GetStmts().size(); i++) {
        HandleStmt(dynamic_cast<CompoundNode*>(stmt)->GetStmts()[i], code);
      }
      break;

    case StmtNode::StmtType::kExpr:
      HandleExpr(dynamic_cast<ExprNode*>(stmt), code);
      break;

    case StmtNode::StmtType::kIf: {
      std::cout << "kIf" << std::endl;
      std::size_t condition_index =
          HandleExpr(dynamic_cast<IfNode*>(stmt)->GetCondition(), code);
      std::vector<Bytecode> true_code;
      std::string true_name("$" + std::to_string(++undefined_name_count_));
      HandleStmt(dynamic_cast<IfNode*>(stmt)->GetBody(), true_code);
      func_list_.push_back(
          std::pair<std::string, std::vector<Bytecode>>(true_name, true_code));
      size_t true_name_index =
          global_memory_.Add(0x01, true_name.size() + 1, true_name.c_str());
      size_t true_name_ptr_index = global_memory_.Add(0x06, 8);
      code.push_back(
          Bytecode(_AQVM_OPERATOR_PTR, true_name_index, true_name_ptr_index));
      if (dynamic_cast<IfNode*>(stmt)->GetElseBody() != nullptr) {
        std::string false_name("$" + std::to_string(++undefined_name_count_));
        std::vector<Bytecode> false_code;
        HandleStmt(dynamic_cast<IfNode*>(stmt)->GetElseBody(), false_code);
        func_list_.push_back(std::pair<std::string, std::vector<Bytecode>>(
            false_name, false_code));
        size_t false_name_index =
            global_memory_.Add(0x01, false_name.size() + 1, false_name.c_str());
        size_t false_name_ptr_index = global_memory_.Add(0x06, 8);
        code.push_back(Bytecode(_AQVM_OPERATOR_PTR, false_name_index,
                                false_name_ptr_index));
        code.push_back(Bytecode(_AQVM_OPERATOR_IF, condition_index,
                                true_name_ptr_index, false_name_ptr_index));
      } else {
        size_t false_name_index = global_memory_.Add(0x01, 3, "$0");
        size_t false_name_ptr_index = global_memory_.Add(0x06, 8);
        code.push_back(Bytecode(_AQVM_OPERATOR_PTR, false_name_index,
                                false_name_ptr_index));
        code.push_back(Bytecode(_AQVM_OPERATOR_IF, condition_index,
                                true_name_ptr_index, false_name_ptr_index));
      }
      break;
    }

    case StmtNode::StmtType::kWhile: {
      std::cout << "kWhile" << std::endl;
      std::size_t condition_index =
          HandleExpr(dynamic_cast<WhileNode*>(stmt)->GetCondition(), code);
      std::vector<Bytecode> body_code;
      std::string body_name("$" + std::to_string(++undefined_name_count_));
      HandleStmt(dynamic_cast<WhileNode*>(stmt)->GetBody(), body_code);
      func_list_.push_back(
          std::pair<std::string, std::vector<Bytecode>>(body_name, body_code));
      size_t body_name_index =
          global_memory_.Add(0x01, body_name.size() + 1, body_name.c_str());
      size_t body_name_ptr_index = global_memory_.Add(0x06, 8);
      code.push_back(
          Bytecode(_AQVM_OPERATOR_PTR, body_name_index, body_name_ptr_index));
      body_code.push_back(Bytecode(_AQVM_OPERATOR_GOTO, body_name_ptr_index));
      size_t void_name_index = global_memory_.Add(0x01, 3, "$0");
      size_t void_name_ptr_index = global_memory_.Add(0x06, 8);
      code.push_back(Bytecode(_AQVM_OPERATOR_IF, condition_index,
                              body_name_ptr_index, void_name_ptr_index));
      break;
    }

    case StmtNode::StmtType::kFuncDecl:
      std::cout << "kFuncDecl" << std::endl;
      HandleFuncDecl(dynamic_cast<FuncDeclNode*>(stmt));
      break;

    case StmtNode::StmtType::kVarDecl:
      std::cout << "kVarDecl" << std::endl;
      HandleVarDecl(dynamic_cast<VarDeclNode*>(stmt), code);
      break;

    case StmtNode::StmtType::kArrayDecl:
      std::cout << "kArrayDecl" << std::endl;
      HandleArrayDecl(dynamic_cast<ArrayDeclNode*>(stmt), code);
      break;

    case StmtNode::StmtType::kFunc:
      std::cout << "kFunc" << std::endl;
      HandleFuncInvoke(dynamic_cast<FuncNode*>(stmt), code);
      break;

    default:
      break;
  }
}

std::size_t BytecodeGenerator::HandleFuncInvoke(FuncNode* func,
                                                std::vector<Bytecode>& code) {
  std::vector<ExprNode*> args = func->GetArgs();
  FuncDeclNode func_decl = func_table_.Find(*func->GetName());

  Type* func_type = func_decl.GetReturnType();
  while (func_type->GetType() == Type::TypeType::kBase ||
         func_type->GetType() == Type::TypeType::kPointer ||
         func_type->GetType() == Type::TypeType::kArray ||
         func_type->GetType() == Type::TypeType::kReference) {
    switch (func_type->GetType()) {
      case Type::TypeType::kConst:
        func_type = dynamic_cast<ConstType*>(func_type)->GetSubType();
        break;
      default:
        break;
    }
  }
  uint8_t vm_type = 0x00;
  if (func_type->GetType() == Type::TypeType::kBase) {
    switch (func_type->GetBaseType()) {
      case Type::BaseType::kVoid:
        vm_type = 0x00;
        break;
      case Type::BaseType::kBool:
      case Type::BaseType::kChar:
        vm_type = 0x01;
        break;
      case Type::BaseType::kShort:
      case Type::BaseType::kInt:
        vm_type = 0x02;
        break;
      case Type::BaseType::kLong:
        vm_type = 0x03;
        break;
      case Type::BaseType::kFloat:
        vm_type = 0x04;
        break;
      case Type::BaseType::kDouble:
        vm_type = 0x05;
        break;
      case Type::BaseType::kStruct:
      case Type::BaseType::kUnion:
      case Type::BaseType::kEnum:
      case Type::BaseType::kPointer:
      case Type::BaseType::kArray:
      case Type::BaseType::kFunction:
      case Type::BaseType::kTypedef:
      case Type::BaseType::kAuto:
        vm_type = 0x06;
        break;
      default:
        vm_type = 0x00;
        break;
    }
  }

  std::vector<std::size_t> vm_args;
  vm_args.push_back(global_memory_.Add(vm_type, func_type->GetSize()));
  vm_args.push_back(args.size());

  for (std::size_t i = 0; i < args.size(); i++) {
    vm_args.push_back(HandleExpr(args[i], code));
  }

  code.push_back(Bytecode(_AQVM_OPERATOR_INVOKE, vm_args));

  return vm_args[0];
}

std::size_t BytecodeGenerator::GetIndex(ExprNode* expr,
                                        std::vector<Bytecode>& code) {
  switch (expr->GetType()) {
    case StmtNode::StmtType::kIdentifier:
      return var_table_.Find(*dynamic_cast<IdentifierNode*>(expr)).second;
    case StmtNode::StmtType::kValue: {
      std::size_t vm_type = dynamic_cast<ValueNode*>(expr)->GetVmType();
      switch (vm_type) {
        case 0x01: {
          int8_t value = dynamic_cast<ValueNode*>(expr)->GetCharValue();
          // std::get<int8_t>(dynamic_cast<ValueNode*>(expr)->GetValue());
          return global_memory_.Add(
              vm_type, dynamic_cast<ValueNode*>(expr)->GetSize(), &value);
          break;
        }
        case 0x02: {
          int value = dynamic_cast<ValueNode*>(expr)->GetIntValue();
          // std::get<int>(dynamic_cast<ValueNode*>(expr)->GetValue());
          return global_memory_.Add(vm_type, 4, &value);
        }
        case 0x03: {
          long value = dynamic_cast<ValueNode*>(expr)->GetLongValue();
          // std::get<long>(dynamic_cast<ValueNode*>(expr)->GetValue());
          return global_memory_.Add(vm_type, 8, &value);
        }
        case 0x04: {
          float value = dynamic_cast<ValueNode*>(expr)->GetFloatValue();
          // std::get<float>(dynamic_cast<ValueNode*>(expr)->GetValue());
          return global_memory_.Add(vm_type, 4, &value);
        }
        case 0x05: {
          double value = dynamic_cast<ValueNode*>(expr)->GetDoubleValue();
          // std::get<double>(dynamic_cast<ValueNode*>(expr)->GetValue());
          return global_memory_.Add(vm_type, 8, &value);
        }
        case 0x06: {
          if (dynamic_cast<ValueNode*>(expr)->GetToken().type ==
              Token::Type::STRING) {
            std::string value =
                dynamic_cast<ValueNode*>(expr)->GetStringValue();
            // std::get<char*>(dynamic_cast<ValueNode*>(expr)->GetValue());
            std::size_t str_index =
                global_memory_.Add(0x01, value.size() + 1,
                                   static_cast<const void*>(value.c_str()));
            std::size_t ptr_index = global_memory_.Add(vm_type, 8);
            code.push_back(Bytecode(_AQVM_OPERATOR_PTR, str_index, ptr_index));
            return ptr_index;
          }
          uint64_t value = dynamic_cast<ValueNode*>(expr)->GetUInt64Value();
          // std::get<uint64_t>(dynamic_cast<ValueNode*>(expr)->GetValue());
          return global_memory_.Add(vm_type, 8, &value);
        }
      }
    }
    case StmtNode::StmtType::kFunc:
      return HandleFuncInvoke(dynamic_cast<FuncNode*>(expr), code);
    default:
      return 0;
  }
}

std::size_t BytecodeGenerator::AddConstInt8t(int8_t value) {
  return global_memory_.Add(0x01, 1, &value);
}

uint8_t BytecodeGenerator::GetExprVmType(ExprNode* expr) {
  if (expr->GetType() == StmtNode::StmtType::kUnary) {
    if (dynamic_cast<UnaryNode*>(expr)->GetOperator() ==
        UnaryNode::Operator::kAddrOf) {
      return 0x06;
    }
    if (dynamic_cast<UnaryNode*>(expr)->GetOperator() ==
        UnaryNode::Operator::CONVERT) {
      switch (dynamic_cast<ConvertNode*>(expr)->GetConvertedType()->GetType()) {
        case Type::TypeType::kBase:
        case Type::TypeType::kConst:
          switch (dynamic_cast<ConvertNode*>(expr)
                      ->GetConvertedType()
                      ->GetBaseType()) {
            case Type::BaseType::kVoid:
              return 0x00;
            case Type::BaseType::kBool:
            case Type::BaseType::kChar:
              return 0x01;
            case Type::BaseType::kShort:
            case Type::BaseType::kInt:
              return 0x02;
            case Type::BaseType::kLong:
              return 0x03;
            case Type::BaseType::kFloat:
              return 0x04;
            case Type::BaseType::kDouble:
              return 0x05;
            case Type::BaseType::kStruct:
            case Type::BaseType::kUnion:
            case Type::BaseType::kEnum:
            case Type::BaseType::kPointer:
            case Type::BaseType::kArray:
            case Type::BaseType::kFunction:
            case Type::BaseType::kTypedef:
            case Type::BaseType::kAuto:
              return 0x06;
            default:
              return 0x00;
          }

        case Type::TypeType::kArray:
        case Type::TypeType::kPointer:
        case Type::TypeType::kReference:
          return 0x06;

        default:
          return 0x00;
      }
    }
    if (dynamic_cast<UnaryNode*>(expr)->GetOperator() ==
        UnaryNode::Operator::ARRAY) {
      return GetExprPtrValueVmType(dynamic_cast<UnaryNode*>(expr)->GetExpr());
    }
    if (dynamic_cast<UnaryNode*>(expr)->GetOperator() ==
        UnaryNode::Operator::kDeref) {
      return GetExprPtrValueVmType(dynamic_cast<UnaryNode*>(expr)->GetExpr());
    }
    return GetExprVmType(dynamic_cast<UnaryNode*>(expr)->GetExpr());
  }
  if (expr->GetType() == StmtNode::StmtType::kBinary) {
    uint8_t left =
        GetExprVmType(dynamic_cast<BinaryNode*>(expr)->GetLeftExpr());
    uint8_t right =
        GetExprVmType(dynamic_cast<BinaryNode*>(expr)->GetRightExpr());

    return left > right ? left : right;
  }
  if (expr->GetType() == StmtNode::StmtType::kValue) {
    return dynamic_cast<ValueNode*>(expr)->GetVmType();
  }
  if (expr->GetType() == StmtNode::StmtType::kConditional) {
    uint8_t true_value =
        GetExprVmType(dynamic_cast<ConditionalNode*>(expr)->GetTrueExpr());
    uint8_t false_value =
        GetExprVmType(dynamic_cast<ConditionalNode*>(expr)->GetFalseExpr());

    return true_value > false_value ? true_value : false_value;
  }
  if (expr->GetType() == StmtNode::StmtType::kFunc) {
    Type* return_type =
        func_table_.Find(*dynamic_cast<FuncNode*>(expr)->GetName())
            .GetReturnType();
    switch (return_type->GetType()) {
      case Type::TypeType::kBase:
      case Type::TypeType::kConst:
        switch (return_type->GetBaseType()) {
          case Type::BaseType::kVoid:
            return 0x00;
          case Type::BaseType::kBool:
          case Type::BaseType::kChar:
            return 0x01;
          case Type::BaseType::kShort:
          case Type::BaseType::kInt:
            return 0x02;
          case Type::BaseType::kLong:
            return 0x03;
          case Type::BaseType::kFloat:
            return 0x04;
          case Type::BaseType::kDouble:
            return 0x05;
          case Type::BaseType::kStruct:
          case Type::BaseType::kUnion:
          case Type::BaseType::kEnum:
          case Type::BaseType::kPointer:
          case Type::BaseType::kArray:
          case Type::BaseType::kFunction:
          case Type::BaseType::kTypedef:
          case Type::BaseType::kAuto:
            return 0x06;
          default:
            return 0x00;
        }

      case Type::TypeType::kArray:
      case Type::TypeType::kPointer:
      case Type::TypeType::kReference:
        return 0x06;

      default:
        return 0x00;
    }
  }
  if (expr->GetType() == StmtNode::StmtType::kIdentifier) {
    switch (var_table_.Find(*dynamic_cast<IdentifierNode*>(expr))
                .first->GetVarType()
                ->GetType()) {
      case Type::TypeType::kBase:
      case Type::TypeType::kConst:
        switch (var_table_.Find(*dynamic_cast<IdentifierNode*>(expr))
                    .first->GetVarType()
                    ->GetBaseType()) {
          case Type::BaseType::kVoid:
            return 0x00;
          case Type::BaseType::kBool:
          case Type::BaseType::kChar:
            return 0x01;
          case Type::BaseType::kShort:
          case Type::BaseType::kInt:
            return 0x02;
          case Type::BaseType::kLong:
            return 0x03;
          case Type::BaseType::kFloat:
            return 0x04;
          case Type::BaseType::kDouble:
            return 0x05;
          case Type::BaseType::kStruct:
          case Type::BaseType::kUnion:
          case Type::BaseType::kEnum:
          case Type::BaseType::kPointer:
          case Type::BaseType::kArray:
          case Type::BaseType::kFunction:
          case Type::BaseType::kTypedef:
          case Type::BaseType::kAuto:
            return 0x06;
          default:
            return 0x00;
        }

      case Type::TypeType::kArray:
      case Type::TypeType::kPointer:
      case Type::TypeType::kReference:
        return 0x06;

      default:
        return 0x00;
    }
  }
  if (expr->GetType() == StmtNode::StmtType::kVarDecl) {
    switch (dynamic_cast<VarDeclNode*>(expr)->GetVarType()->GetType()) {
      case Type::TypeType::kBase:
      case Type::TypeType::kConst:
        switch (dynamic_cast<VarDeclNode*>(expr)->GetVarType()->GetBaseType()) {
          case Type::BaseType::kVoid:
            return 0x00;
          case Type::BaseType::kBool:
          case Type::BaseType::kChar:
            return 0x01;
          case Type::BaseType::kShort:
          case Type::BaseType::kInt:
            return 0x02;
          case Type::BaseType::kLong:
            return 0x03;
          case Type::BaseType::kFloat:
            return 0x04;
          case Type::BaseType::kDouble:
            return 0x05;
          case Type::BaseType::kStruct:
          case Type::BaseType::kUnion:
          case Type::BaseType::kEnum:
          case Type::BaseType::kPointer:
          case Type::BaseType::kArray:
          case Type::BaseType::kFunction:
          case Type::BaseType::kTypedef:
          case Type::BaseType::kAuto:
            return 0x06;
          default:
            return 0x00;
        }

      case Type::TypeType::kArray:
      case Type::TypeType::kPointer:
      case Type::TypeType::kReference:
        return 0x06;

      default:
        return 0x00;
    }
  }
  if (expr->GetType() == StmtNode::StmtType::kCast) {
    switch (dynamic_cast<CastNode*>(expr)->GetCastType()->GetType()) {
      case Type::TypeType::kBase:
      case Type::TypeType::kConst:
        switch (dynamic_cast<CastNode*>(expr)->GetCastType()->GetBaseType()) {
          case Type::BaseType::kVoid:
            return 0x00;
          case Type::BaseType::kBool:
          case Type::BaseType::kChar:
            return 0x01;
          case Type::BaseType::kShort:
          case Type::BaseType::kInt:
            return 0x02;
          case Type::BaseType::kLong:
            return 0x03;
          case Type::BaseType::kFloat:
            return 0x04;
          case Type::BaseType::kDouble:
            return 0x05;
          case Type::BaseType::kStruct:
          case Type::BaseType::kUnion:
          case Type::BaseType::kEnum:
          case Type::BaseType::kPointer:
          case Type::BaseType::kArray:
          case Type::BaseType::kFunction:
          case Type::BaseType::kTypedef:
          case Type::BaseType::kAuto:
            return 0x06;
          default:
            return 0x00;
        }

      case Type::TypeType::kArray:
      case Type::TypeType::kPointer:
      case Type::TypeType::kReference:
        return 0x06;

      default:
        return 0x00;
    }
  }
  return 0x00;
}

uint8_t BytecodeGenerator::GetExprPtrValueVmType(ExprNode* expr) {
  if (expr->GetType() == StmtNode::StmtType::kUnary) {
    if (dynamic_cast<UnaryNode*>(expr)->GetOperator() ==
        UnaryNode::Operator::kAddrOf) {
      return GetExprVmType(dynamic_cast<UnaryNode*>(expr)->GetExpr());
    }
    if (dynamic_cast<UnaryNode*>(expr)->GetOperator() ==
        UnaryNode::Operator::CONVERT) {
      switch (dynamic_cast<ConvertNode*>(expr)->GetConvertedType()->GetType()) {
        case Type::TypeType::kBase:
        case Type::TypeType::kConst:
          switch (dynamic_cast<ConvertNode*>(expr)
                      ->GetConvertedType()
                      ->GetBaseType()) {
            case Type::BaseType::kVoid:
              return 0x00;
            case Type::BaseType::kBool:
            case Type::BaseType::kChar:
              return 0x01;
            case Type::BaseType::kShort:
            case Type::BaseType::kInt:
              return 0x02;
            case Type::BaseType::kLong:
              return 0x03;
            case Type::BaseType::kFloat:
              return 0x04;
            case Type::BaseType::kDouble:
              return 0x05;
            case Type::BaseType::kStruct:
            case Type::BaseType::kUnion:
            case Type::BaseType::kEnum:
            case Type::BaseType::kPointer:
            case Type::BaseType::kArray:
            case Type::BaseType::kFunction:
            case Type::BaseType::kTypedef:
            case Type::BaseType::kAuto:
              return 0x06;
            default:
              return 0x00;
          }

        case Type::TypeType::kArray:
        case Type::TypeType::kPointer:
        case Type::TypeType::kReference:
          return GetExprPtrValueVmType(
              dynamic_cast<UnaryNode*>(expr)->GetExpr());

        default:
          return 0x00;
      }
    }
    if (dynamic_cast<UnaryNode*>(expr)->GetOperator() ==
        UnaryNode::Operator::ARRAY) {
      return GetExprPtrValueVmType(dynamic_cast<UnaryNode*>(expr)->GetExpr());
    }
    return GetExprPtrValueVmType(dynamic_cast<UnaryNode*>(expr)->GetExpr());
  }
  if (expr->GetType() == StmtNode::StmtType::kBinary) {
    uint8_t left =
        GetExprPtrValueVmType(dynamic_cast<BinaryNode*>(expr)->GetLeftExpr());
    uint8_t right =
        GetExprPtrValueVmType(dynamic_cast<BinaryNode*>(expr)->GetRightExpr());

    return left > right ? left : right;
  }
  if (expr->GetType() == StmtNode::StmtType::kValue) {
    return dynamic_cast<ValueNode*>(expr)->GetVmType();
  }
  if (expr->GetType() == StmtNode::StmtType::kConditional) {
    uint8_t true_value = GetExprPtrValueVmType(
        dynamic_cast<ConditionalNode*>(expr)->GetTrueExpr());
    uint8_t false_value = GetExprPtrValueVmType(
        dynamic_cast<ConditionalNode*>(expr)->GetFalseExpr());

    return true_value > false_value ? true_value : false_value;
  }
  if (expr->GetType() == StmtNode::StmtType::kFunc) {
    Type* return_type =
        func_table_.Find(*dynamic_cast<FuncNode*>(expr)->GetName())
            .GetReturnType();
    switch (return_type->GetType()) {
      case Type::TypeType::kBase:
      case Type::TypeType::kConst:
        switch (return_type->GetBaseType()) {
          case Type::BaseType::kVoid:
            return 0x00;
          case Type::BaseType::kBool:
          case Type::BaseType::kChar:
            return 0x01;
          case Type::BaseType::kShort:
          case Type::BaseType::kInt:
            return 0x02;
          case Type::BaseType::kLong:
            return 0x03;
          case Type::BaseType::kFloat:
            return 0x04;
          case Type::BaseType::kDouble:
            return 0x05;
          case Type::BaseType::kStruct:
          case Type::BaseType::kUnion:
          case Type::BaseType::kEnum:
          case Type::BaseType::kPointer:
          case Type::BaseType::kArray:
          case Type::BaseType::kFunction:
          case Type::BaseType::kTypedef:
          case Type::BaseType::kAuto:
            return 0x06;
          default:
            return 0x00;
        }

      case Type::TypeType::kArray:
        switch (
            dynamic_cast<ArrayType*>(return_type)->GetSubType()->GetType()) {
          case Type::TypeType::kBase:
          case Type::TypeType::kConst:
            switch (dynamic_cast<ArrayType*>(return_type)
                        ->GetSubType()
                        ->GetBaseType()) {
              case Type::BaseType::kVoid:
                return 0x00;
              case Type::BaseType::kBool:
              case Type::BaseType::kChar:
                return 0x01;
              case Type::BaseType::kShort:
              case Type::BaseType::kInt:
                return 0x02;
              case Type::BaseType::kLong:
                return 0x03;
              case Type::BaseType::kFloat:
                return 0x04;
              case Type::BaseType::kDouble:
                return 0x05;
              case Type::BaseType::kStruct:
              case Type::BaseType::kUnion:
              case Type::BaseType::kEnum:
              case Type::BaseType::kPointer:
              case Type::BaseType::kArray:
              case Type::BaseType::kFunction:
              case Type::BaseType::kTypedef:
              case Type::BaseType::kAuto:
                return 0x06;
              default:
                return 0x00;
            }

          case Type::TypeType::kArray:
          case Type::TypeType::kPointer:
          case Type::TypeType::kReference:
            return 0x06;

          default:
            return 0x00;
        }
      case Type::TypeType::kPointer:
        switch (
            dynamic_cast<PointerType*>(return_type)->GetSubType()->GetType()) {
          case Type::TypeType::kBase:
          case Type::TypeType::kConst:
            switch (dynamic_cast<PointerType*>(return_type)
                        ->GetSubType()
                        ->GetBaseType()) {
              case Type::BaseType::kVoid:
                return 0x00;
              case Type::BaseType::kBool:
              case Type::BaseType::kChar:
                return 0x01;
              case Type::BaseType::kShort:
              case Type::BaseType::kInt:
                return 0x02;
              case Type::BaseType::kLong:
                return 0x03;
              case Type::BaseType::kFloat:
                return 0x04;
              case Type::BaseType::kDouble:
                return 0x05;
              case Type::BaseType::kStruct:
              case Type::BaseType::kUnion:
              case Type::BaseType::kEnum:
              case Type::BaseType::kPointer:
              case Type::BaseType::kArray:
              case Type::BaseType::kFunction:
              case Type::BaseType::kTypedef:
              case Type::BaseType::kAuto:
                return 0x06;
              default:
                return 0x00;
            }

          case Type::TypeType::kArray:
          case Type::TypeType::kPointer:
          case Type::TypeType::kReference:
            return 0x06;

          default:
            return 0x00;
        }
      case Type::TypeType::kReference:
        switch (dynamic_cast<ReferenceType*>(return_type)
                    ->GetSubType()
                    ->GetType()) {
          case Type::TypeType::kBase:
          case Type::TypeType::kConst:
            switch (dynamic_cast<ReferenceType*>(return_type)
                        ->GetSubType()
                        ->GetBaseType()) {
              case Type::BaseType::kVoid:
                return 0x00;
              case Type::BaseType::kBool:
              case Type::BaseType::kChar:
                return 0x01;
              case Type::BaseType::kShort:
              case Type::BaseType::kInt:
                return 0x02;
              case Type::BaseType::kLong:
                return 0x03;
              case Type::BaseType::kFloat:
                return 0x04;
              case Type::BaseType::kDouble:
                return 0x05;
              case Type::BaseType::kStruct:
              case Type::BaseType::kUnion:
              case Type::BaseType::kEnum:
              case Type::BaseType::kPointer:
              case Type::BaseType::kArray:
              case Type::BaseType::kFunction:
              case Type::BaseType::kTypedef:
              case Type::BaseType::kAuto:
                return 0x06;
              default:
                return 0x00;
            }

          case Type::TypeType::kArray:
          case Type::TypeType::kPointer:
          case Type::TypeType::kReference:
            return 0x06;

          default:
            return 0x00;
        }
      default:
        return 0x00;
    }
    if (expr->GetType() == StmtNode::StmtType::kIdentifier) {
      switch (var_table_.Find(*dynamic_cast<IdentifierNode*>(expr))
                  .first->GetVarType()
                  ->GetType()) {
        case Type::TypeType::kBase:
        case Type::TypeType::kConst:
          switch (var_table_.Find(*dynamic_cast<IdentifierNode*>(expr))
                      .first->GetVarType()
                      ->GetBaseType()) {
            case Type::BaseType::kVoid:
              return 0x00;
            case Type::BaseType::kBool:
            case Type::BaseType::kChar:
              return 0x01;
            case Type::BaseType::kShort:
            case Type::BaseType::kInt:
              return 0x02;
            case Type::BaseType::kLong:
              return 0x03;
            case Type::BaseType::kFloat:
              return 0x04;
            case Type::BaseType::kDouble:
              return 0x05;
            case Type::BaseType::kStruct:
            case Type::BaseType::kUnion:
            case Type::BaseType::kEnum:
            case Type::BaseType::kPointer:
            case Type::BaseType::kArray:
            case Type::BaseType::kFunction:
            case Type::BaseType::kTypedef:
            case Type::BaseType::kAuto:
              return 0x06;
            default:
              return 0x00;
          }

        case Type::TypeType::kArray:
          switch (dynamic_cast<ArrayType*>(
                      var_table_.Find(*dynamic_cast<IdentifierNode*>(expr))
                          .first->GetVarType())
                      ->GetSubType()
                      ->GetType()) {
            case Type::TypeType::kBase:
            case Type::TypeType::kConst:
              switch (dynamic_cast<ArrayType*>(
                          var_table_.Find(*dynamic_cast<IdentifierNode*>(expr))
                              .first->GetVarType())
                          ->GetSubType()
                          ->GetBaseType()) {
                case Type::BaseType::kVoid:
                  return 0x00;
                case Type::BaseType::kBool:
                case Type::BaseType::kChar:
                  return 0x01;
                case Type::BaseType::kShort:
                case Type::BaseType::kInt:
                  return 0x02;
                case Type::BaseType::kLong:
                  return 0x03;
                case Type::BaseType::kFloat:
                  return 0x04;
                case Type::BaseType::kDouble:
                  return 0x05;
                case Type::BaseType::kStruct:
                case Type::BaseType::kUnion:
                case Type::BaseType::kEnum:
                case Type::BaseType::kPointer:
                case Type::BaseType::kArray:
                case Type::BaseType::kFunction:
                case Type::BaseType::kTypedef:
                case Type::BaseType::kAuto:
                  return 0x06;
                default:
                  return 0x00;
              }

            case Type::TypeType::kArray:
            case Type::TypeType::kPointer:
            case Type::TypeType::kReference:
              return 0x06;

            default:
              return 0x00;
          }
        case Type::TypeType::kPointer:
          switch (dynamic_cast<PointerType*>(
                      var_table_.Find(*dynamic_cast<IdentifierNode*>(expr))
                          .first->GetVarType())
                      ->GetSubType()
                      ->GetType()) {
            case Type::TypeType::kBase:
            case Type::TypeType::kConst:
              switch (dynamic_cast<PointerType*>(
                          var_table_.Find(*dynamic_cast<IdentifierNode*>(expr))
                              .first->GetVarType())
                          ->GetSubType()
                          ->GetBaseType()) {
                case Type::BaseType::kVoid:
                  return 0x00;
                case Type::BaseType::kBool:
                case Type::BaseType::kChar:
                  return 0x01;
                case Type::BaseType::kShort:
                case Type::BaseType::kInt:
                  return 0x02;
                case Type::BaseType::kLong:
                  return 0x03;
                case Type::BaseType::kFloat:
                  return 0x04;
                case Type::BaseType::kDouble:
                  return 0x05;
                case Type::BaseType::kStruct:
                case Type::BaseType::kUnion:
                case Type::BaseType::kEnum:
                case Type::BaseType::kPointer:
                case Type::BaseType::kArray:
                case Type::BaseType::kFunction:
                case Type::BaseType::kTypedef:
                case Type::BaseType::kAuto:
                  return 0x06;
                default:
                  return 0x00;
              }

            case Type::TypeType::kArray:
            case Type::TypeType::kPointer:
            case Type::TypeType::kReference:
              return 0x06;

            default:
              return 0x00;
          }
        case Type::TypeType::kReference:
          switch (dynamic_cast<ReferenceType*>(
                      var_table_.Find(*dynamic_cast<IdentifierNode*>(expr))
                          .first->GetVarType())
                      ->GetSubType()
                      ->GetType()) {
            case Type::TypeType::kBase:
            case Type::TypeType::kConst:
              switch (dynamic_cast<ReferenceType*>(
                          var_table_.Find(*dynamic_cast<IdentifierNode*>(expr))
                              .first->GetVarType())
                          ->GetSubType()
                          ->GetBaseType()) {
                case Type::BaseType::kVoid:
                  return 0x00;
                case Type::BaseType::kBool:
                case Type::BaseType::kChar:
                  return 0x01;
                case Type::BaseType::kShort:
                case Type::BaseType::kInt:
                  return 0x02;
                case Type::BaseType::kLong:
                  return 0x03;
                case Type::BaseType::kFloat:
                  return 0x04;
                case Type::BaseType::kDouble:
                  return 0x05;
                case Type::BaseType::kStruct:
                case Type::BaseType::kUnion:
                case Type::BaseType::kEnum:
                case Type::BaseType::kPointer:
                case Type::BaseType::kArray:
                case Type::BaseType::kFunction:
                case Type::BaseType::kTypedef:
                case Type::BaseType::kAuto:
                  return 0x06;
                default:
                  return 0x00;
              }

            case Type::TypeType::kArray:
            case Type::TypeType::kPointer:
            case Type::TypeType::kReference:
              return 0x06;

            default:
              return 0x00;
          }

        default:
          return 0x00;
      }
    }
    if (expr->GetType() == StmtNode::StmtType::kVarDecl) {
      switch (dynamic_cast<VarDeclNode*>(expr)->GetVarType()->GetType()) {
        case Type::TypeType::kBase:
        case Type::TypeType::kConst:
          switch (
              dynamic_cast<VarDeclNode*>(expr)->GetVarType()->GetBaseType()) {
            case Type::BaseType::kVoid:
              return 0x00;
            case Type::BaseType::kBool:
            case Type::BaseType::kChar:
              return 0x01;
            case Type::BaseType::kShort:
            case Type::BaseType::kInt:
              return 0x02;
            case Type::BaseType::kLong:
              return 0x03;
            case Type::BaseType::kFloat:
              return 0x04;
            case Type::BaseType::kDouble:
              return 0x05;
            case Type::BaseType::kStruct:
            case Type::BaseType::kUnion:
            case Type::BaseType::kEnum:
            case Type::BaseType::kPointer:
            case Type::BaseType::kArray:
            case Type::BaseType::kFunction:
            case Type::BaseType::kTypedef:
            case Type::BaseType::kAuto:
              return 0x06;
            default:
              return 0x00;
          }

        case Type::TypeType::kArray:
          switch (dynamic_cast<ArrayType*>(
                      dynamic_cast<VarDeclNode*>(expr)->GetVarType())
                      ->GetSubType()
                      ->GetType()) {
            case Type::TypeType::kBase:
            case Type::TypeType::kConst:
              switch (dynamic_cast<ArrayType*>(
                          dynamic_cast<VarDeclNode*>(expr)->GetVarType())
                          ->GetSubType()
                          ->GetBaseType()) {
                case Type::BaseType::kVoid:
                  return 0x00;
                case Type::BaseType::kBool:
                case Type::BaseType::kChar:
                  return 0x01;
                case Type::BaseType::kShort:
                case Type::BaseType::kInt:
                  return 0x02;
                case Type::BaseType::kLong:
                  return 0x03;
                case Type::BaseType::kFloat:
                  return 0x04;
                case Type::BaseType::kDouble:
                  return 0x05;
                case Type::BaseType::kStruct:
                case Type::BaseType::kUnion:
                case Type::BaseType::kEnum:
                case Type::BaseType::kPointer:
                case Type::BaseType::kArray:
                case Type::BaseType::kFunction:
                case Type::BaseType::kTypedef:
                case Type::BaseType::kAuto:
                  return 0x06;
                default:
                  return 0x00;
              }

            case Type::TypeType::kArray:
            case Type::TypeType::kPointer:
            case Type::TypeType::kReference:
              return 0x06;

            default:
              return 0x00;
          }
        case Type::TypeType::kPointer:
          switch (dynamic_cast<PointerType*>(
                      dynamic_cast<VarDeclNode*>(expr)->GetVarType())
                      ->GetSubType()
                      ->GetType()) {
            case Type::TypeType::kBase:
            case Type::TypeType::kConst:
              switch (dynamic_cast<PointerType*>(
                          dynamic_cast<VarDeclNode*>(expr)->GetVarType())
                          ->GetSubType()
                          ->GetBaseType()) {
                case Type::BaseType::kVoid:
                  return 0x00;
                case Type::BaseType::kBool:
                case Type::BaseType::kChar:
                  return 0x01;
                case Type::BaseType::kShort:
                case Type::BaseType::kInt:
                  return 0x02;
                case Type::BaseType::kLong:
                  return 0x03;
                case Type::BaseType::kFloat:
                  return 0x04;
                case Type::BaseType::kDouble:
                  return 0x05;
                case Type::BaseType::kStruct:
                case Type::BaseType::kUnion:
                case Type::BaseType::kEnum:
                case Type::BaseType::kPointer:
                case Type::BaseType::kArray:
                case Type::BaseType::kFunction:
                case Type::BaseType::kTypedef:
                case Type::BaseType::kAuto:
                  return 0x06;
                default:
                  return 0x00;
              }

            case Type::TypeType::kArray:
            case Type::TypeType::kPointer:
            case Type::TypeType::kReference:
              return 0x06;

            default:
              return 0x00;
          }
        case Type::TypeType::kReference:
          switch (dynamic_cast<ReferenceType*>(
                      dynamic_cast<VarDeclNode*>(expr)->GetVarType())
                      ->GetSubType()
                      ->GetType()) {
            case Type::TypeType::kBase:
            case Type::TypeType::kConst:
              switch (dynamic_cast<ReferenceType*>(
                          dynamic_cast<VarDeclNode*>(expr)->GetVarType())
                          ->GetSubType()
                          ->GetBaseType()) {
                case Type::BaseType::kVoid:
                  return 0x00;
                case Type::BaseType::kBool:
                case Type::BaseType::kChar:
                  return 0x01;
                case Type::BaseType::kShort:
                case Type::BaseType::kInt:
                  return 0x02;
                case Type::BaseType::kLong:
                  return 0x03;
                case Type::BaseType::kFloat:
                  return 0x04;
                case Type::BaseType::kDouble:
                  return 0x05;
                case Type::BaseType::kStruct:
                case Type::BaseType::kUnion:
                case Type::BaseType::kEnum:
                case Type::BaseType::kPointer:
                case Type::BaseType::kArray:
                case Type::BaseType::kFunction:
                case Type::BaseType::kTypedef:
                case Type::BaseType::kAuto:
                  return 0x06;
                default:
                  return 0x00;
              }

            case Type::TypeType::kArray:
            case Type::TypeType::kPointer:
            case Type::TypeType::kReference:
              return 0x06;

            default:
              return 0x00;
          }

        default:
          return 0x00;
      }
    }
  }
  if (expr->GetType() == StmtNode::StmtType::kCast) {
    switch (dynamic_cast<CastNode*>(expr)->GetCastType()->GetType()) {
      case Type::TypeType::kBase:
      case Type::TypeType::kConst:
        switch (dynamic_cast<CastNode*>(expr)->GetCastType()->GetBaseType()) {
          case Type::BaseType::kVoid:
            return 0x00;
          case Type::BaseType::kBool:
          case Type::BaseType::kChar:
            return 0x01;
          case Type::BaseType::kShort:
          case Type::BaseType::kInt:
            return 0x02;
          case Type::BaseType::kLong:
            return 0x03;
          case Type::BaseType::kFloat:
            return 0x04;
          case Type::BaseType::kDouble:
            return 0x05;
          case Type::BaseType::kStruct:
          case Type::BaseType::kUnion:
          case Type::BaseType::kEnum:
          case Type::BaseType::kPointer:
          case Type::BaseType::kArray:
          case Type::BaseType::kFunction:
          case Type::BaseType::kTypedef:
          case Type::BaseType::kAuto:
            return 0x06;
          default:
            return 0x00;
        }

      case Type::TypeType::kArray:
      case Type::TypeType::kPointer:
      case Type::TypeType::kReference:
        return 0x06;

      default:
        return 0x00;
    }
  }
  return 0x00;
}

std::size_t BytecodeGenerator::GetExprVmSize(uint8_t type) {
  switch (type) {
    case 0x01:
      return 1;
    case 0x02:
      return 4;
    case 0x03:
      return 8;
    case 0x04:
      return 4;
    case 0x05:
      return 8;
    case 0x06:
      return 8;
    default:
      return 0;
  }
}
uint64_t BytecodeGenerator::SwapUint64t(uint64_t x) {
  x = ((x << 56) & 0xFF00000000000000ULL) |
      ((x << 40) & 0x00FF000000000000ULL) |
      ((x << 24) & 0x0000FF0000000000ULL) | ((x << 8) & 0x000000FF00000000ULL) |
      ((x >> 8) & 0x00000000FF000000ULL) | ((x >> 24) & 0x0000000000FF0000ULL) |
      ((x >> 40) & 0x000000000000FF00ULL) | ((x >> 56) & 0x00000000000000FFULL);
  return x;
}

void BytecodeGenerator::InsertUint64ToCode(uint64_t value) {
  for (int i = 0; i < 8; ++i) {
    code_.push_back(static_cast<uint8_t>((value >> (i * 8)) & 0xFF));
  }
}

size_t BytecodeGenerator::EncodeUleb128(size_t value,
                                        std::vector<uint8_t>& output) {
  size_t count = 0;
  do {
    uint8_t byte = value & 0x7F;
    value >>= 7;
    if (value != 0) {
      byte |= 0x80;
    }
    output.push_back(byte);
    count++;
  } while (value != 0);
  return count;
}
